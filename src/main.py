import json
import logging
import os
import re
import time
from textwrap import dedent

import sentry_sdk
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from sentry_sdk.crons import capture_checkin
from sentry_sdk.crons.consts import MonitorStatus
from sentry_sdk.integrations.logging import LoggingIntegration

from utils import logger, set_up_logging, random_str, get_azure_table_client

# BUILD_INFO is generated by the build pipeline (e.g. docker/metadata-action).
# It looks like:
# {"tags":["ghcr.io/watonomous/repo-ingestion:main"],"labels":{"org.opencontainers.image.title":"repo-ingestion","org.opencontainers.image.description":"Simple server to receive file changes and open GitHub pull requests","org.opencontainers.image.url":"https://github.com/WATonomous/repo-ingestion","org.opencontainers.image.source":"https://github.com/WATonomous/repo-ingestion","org.opencontainers.image.version":"main","org.opencontainers.image.created":"2024-01-20T16:10:39.421Z","org.opencontainers.image.revision":"1d55b62b15c78251e0560af9e97927591e260a98","org.opencontainers.image.licenses":""}}
BUILD_INFO = json.loads(os.getenv("DOCKER_METADATA_OUTPUT_JSON", "{}"))
IS_SENTRY_ENABLED = not not os.getenv("SENTRY_DSN")

# Set up Sentry
if IS_SENTRY_ENABLED:
    build_labels = BUILD_INFO.get("labels", {})
    image_title = build_labels.get("org.opencontainers.image.title", "unknown_image")
    image_version = build_labels.get(
        "org.opencontainers.image.version", "unknown_version"
    )
    image_rev = build_labels.get("org.opencontainers.image.revision", "unknown_rev")

    sentry_config = {
        "dsn": os.environ["SENTRY_DSN"],
        "environment": os.getenv("DEPLOYMENT_ENVIRONMENT", "unknown"),
        "release": os.getenv(
            "SENTRY_RELEASE", f"{image_title}:{image_version}@{image_rev}"
        ),
    }

    print(f"Sentry SDK version: {sentry_sdk.VERSION}")
    print(f"Sentry DSN found. Setting up Sentry with config: {sentry_config}")

    sentry_logging = LoggingIntegration(
        level=logging.INFO,  # Capture info and above as breadcrumbs
        event_level=logging.ERROR,  # Send errors as events
    )

    def sentry_traces_sampler(sampling_context):
        # Inherit parent sampling decision
        if sampling_context["parent_sampled"] is not None:
            return sampling_context["parent_sampled"]

        # Don't need to sample health checks
        if sampling_context.get("asgi_scope", {}).get("path", "").startswith("/health"):
            return 0

        # Sample everything else
        return 1

    sentry_sdk.init(
        **sentry_config,
        integrations=[sentry_logging],
        # Set traces_sample_rate to 1.0 to capture 100%
        # of transactions for performance monitoring.
        # We recommend adjusting this value in production,
        # traces_sample_rate=1.0,
        traces_sampler=sentry_traces_sampler,
        enable_tracing=True,
    )
else:
    print("No Sentry DSN found. Skipping Sentry setup.")

app = FastAPI()
state = {
    "sentry_cron_last_ping_time": 0,
    "num_signups": 0,
    "num_successful_confirms": 0,
    "num_failed_confirms": 0,
}

# Add CORS for local development. In production, this is handled by the reverse proxy.
origins = [
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.on_event("startup")
async def startup_event():
    set_up_logging()
    logger.info(
        f"Logging configured with level {logger.level} ({logging.getLevelName(logger.level)})"
    )


@app.get("/health")
def read_health():
    current_time = time.time()
    success = True
    # Assuming the /health endpoint is called every 10 seconds, ping Sentry about once every minute.
    if IS_SENTRY_ENABLED and current_time - state["sentry_cron_last_ping_time"] > 50:
        state["sentry_cron_last_ping_time"] = current_time
        capture_checkin(
            monitor_slug="repo-ingestion",
            status=MonitorStatus.OK if success else MonitorStatus.ERROR,
            monitor_config={
                "schedule": {"type": "interval", "value": 1, "unit": "minute"},
                "checkin_margin": 5,  # minutes
                "max_runtime": 1,  # minutes
                "failure_issue_threshold": 1,
                "recovery_threshold": 2,
            },
        )
        logging.info(f"Pinged Sentry CRON with status {'OK' if success else 'ERROR'}")

    return {"status": "ok"}


@app.get("/build-info")
def read_build_info():
    return BUILD_INFO


@app.get("/runtime-info")
def read_runtime_info():
    return {
        "sentry_enabled": IS_SENTRY_ENABLED,
        "sentry_sdk_version": sentry_sdk.VERSION,
        "deployment_environment": os.getenv("DEPLOYMENT_ENVIRONMENT", "unknown"),
        "sentry_cron_last_ping_time": state["sentry_cron_last_ping_time"],
        "num_signups": state["num_signups"],
        "num_successful_confirms": state["num_successful_confirms"],
        "num_failed_confirms": state["num_failed_confirms"],
    }


table_client = get_azure_table_client("signups", create_table_if_not_exists=True)


class SignUpRequest(BaseModel):
    mailing_list: str
    email: str


CODE_TTL_SEC = 15 * 60


@app.post("/sign_up")
def sign_up(req: SignUpRequest):
    # validate email
    if not re.match(r"[^@]+@[^@]+\.[^@]+", req.email):
        raise HTTPException(status_code=400, detail="Invalid email")

    # Generate a random code
    code = random_str(10)

    table_client.upsert_entity(
        entity={
            "PartitionKey": req.mailing_list,
            "RowKey": req.email,
            "CreatedAt": time.time(),
            "Code": code,
        }
    )

    # TODO: Send email with code

    state["num_signups"] += 1

    return {"status": "ok", "message": f"Confirmation email sent to '{req.email}'."}


@app.get("/confirm/{mailing_list}/{email}/{code}")
def confirm(mailing_list: str, email: str, code: str):
    from azure.core.exceptions import ResourceNotFoundError
    try:
        entity = table_client.get_entity(partition_key=mailing_list, row_key=email)
    except ResourceNotFoundError:
        state["num_failed_confirms"] += 1
        raise HTTPException(status_code=400, detail="Code expired or invalid")

    if entity["Code"] != code or time.time() - entity["CreatedAt"] > CODE_TTL_SEC:
        state["num_failed_confirms"] += 1
        raise HTTPException(status_code=400, detail="Code expired or invalid")

    # TODO: Add email to mailing list

    # delete the entity
    table_client.delete_entity(partition_key=mailing_list, row_key=email)

    return {
        "status": "ok",
        "message": f"Subscription confirmed! '{email}' has been added to the '{mailing_list}' mailing list.",
    }


# TODO: run this on a schedule
@app.post("/cleanup")
def cleanup():
    """
    Clean up expired signups.
    """
    expired_entities = table_client.query_entities(
        query_filter=f"CreatedAt lt @ExpiryTime",
        select=["PartitionKey", "RowKey"],
        parameters={"ExpiryTime": time.time() - CODE_TTL_SEC},
        headers={"Accept": "application/json;odata=nometadata"},
    )
    deleted_count = 0
    for entity in expired_entities:
        table_client.delete_entity(partition_key=entity["PartitionKey"], row_key=entity["RowKey"])
        deleted_count += 1

    return {"status": "ok", "message": f"Deleted {deleted_count} expired signups."}
